Well, that was a whirlwind tour of QA, and you probably have many more questions that you’d like answered (pun intended!). In this chapter, we discussed two approaches to QA (extractive and generative) and examined two different retrieval algorithms (BM25 and DPR). Along the way, we saw that domain adaptation can be a simple technique to boost the performance of our QA system by a significant margin, and we looked at a few of the most common metrics that are used for evaluating such systems. Although we focused on closed-domain QA (i.e., a single domain of elec‐tronic products), the techniques in this chapter can easily be generalized to the open-domain case; we recommend reading Cloudera’s excellent Fast Forward  to see what’s involved.
Deploying QA systems in the wild can be a tricky business to get right, and our expe‐rience is that a significant part of the value comes from first providing end users with useful search capabilities, followed by an extractive component. In this respect, the reader can be used in novel ways beyond answering on-demand user queries. For example, researchers at  were able to use their reader to automatically extract a set of pros andproduct in a client’s catalog. They also showed that a reader can be used to extract named entities in a zero-shot fashion by creating queries like “What kind of camera?” Given its infancy and subtle failure modes, we recommend exploring generative QA only once the other two approaches have been exhausted. This “hierarchy of needs” for tackling QA problems is illustrated in Figure 7-14.
Figure 7-14. Te QA hierarchy of needs
Looking ahead, one exciting research area is multimodal QA, which involves QA over multiple modalities like text, tables, and images. As described in the MultiModalQA benchmark,17 such systems could enable users to answer complex questions that inte‐grate information across different modalities, like “When was the famous painting with two touching fingers completed?” Another area with practical business applica‐tions is QA over a knowledge graph, where the nodes of the graph correspond to real-world entities and their relations are defined by the edges. By encoding factoids as (subject, predicate, object) triples, one can use the graph to answer questions about a missing element. For an example that combines transformers with knowledge graphs, see the . One more promising direction is automatic question gener‐ation ame form of unsupervised/weakly supervised training using unlabeled data or data augmentation. Two recent examples include the papers on the Probably Answered Questions (PAQ) benchmark and synthetic data augmentation for cross-lingual settings.18
In this chapter we’ve seen that in order to successfully use QA models for real-world use cases we need to apply a few tricks, such as implementing a fast retrieval pipeline to make predictions in near real time. Still, applying a QA model to a handful of pre‐selected documents can take a couple of seconds on production hardware. Although this may not sound like much, imagine how different your experience would be if you had to wait a few seconds to get the results of a Google search—a few seconds of wait time can decide the fate of your transformer-powered application. In the next chapter we’ll have a look at a few methods to accelerate model predictions further.
CHAPTER 11
